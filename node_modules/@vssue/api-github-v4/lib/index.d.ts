import { VssueAPI } from 'vssue';
import { AxiosInstance } from 'axios';
/**
 * Github GraphQL API v4
 *
 * @see https://developer.github.com/v4/
 * @see https://developer.github.com/v4/explorer/
 * @see https://developer.github.com/apps/building-oauth-apps/
 */
export default class GithubV4 implements VssueAPI.Instance {
    baseURL: string;
    owner: string;
    repo: string;
    labels: Array<string>;
    clientId: string;
    clientSecret: string;
    state: string;
    proxy: string | ((url: string) => string);
    $http: AxiosInstance;
    private _pageInfo;
    private _issueNodeId;
    constructor({ baseURL, owner, repo, labels, clientId, clientSecret, state, proxy, }: VssueAPI.Options);
    /**
     * The platform api info
     */
    readonly platform: VssueAPI.Platform;
    /**
     * Redirect to the authorization page of platform.
     *
     * @see https://developer.github.com/apps/building-oauth-apps/authorizing-oauth-apps/#1-request-a-users-github-identity
     */
    redirectAuth(): void;
    /**
     * Handle authorization.
     *
     * @return A string for access token, `null` for no authorization code
     *
     * @see https://developer.github.com/apps/building-oauth-apps/authorizing-oauth-apps/
     *
     * @remarks
     * If the `code` and `state` exist in the query, and the `state` matches, remove them from query, and try to get the access token.
     */
    handleAuth(): Promise<VssueAPI.AccessToken>;
    /**
     * Get user access token via `code`
     *
     * @param options.code - The code from the query
     *
     * @return User access token
     *
     * @see https://developer.github.com/apps/building-oauth-apps/authorizing-oauth-apps/#2-users-are-redirected-back-to-your-site-by-github
     */
    getAccessToken({ code, }: {
        code: string;
    }): Promise<string>;
    /**
     * Get the logined user with access token.
     *
     * @param options.accessToken - User access token
     *
     * @return The user
     *
     * @see https://developer.github.com/v4/query/ viewer
     * @see https://developer.github.com/v4/object/user/
     */
    getUser({ accessToken, }: {
        accessToken: VssueAPI.AccessToken;
    }): Promise<VssueAPI.User>;
    /**
     * Get issue of this page according to the issue id or the issue title
     *
     * @param options.accessToken - User access token
     * @param options.issueId - The id of issue
     * @param options.issueTitle - The title of issue
     *
     * @return The raw response of issue
     *
     * @see https://developer.github.com/v4/object/repository/
     * @see https://developer.github.com/v4/object/issueconnection/
     * @see https://developer.github.com/v4/object/issue/
     *
     * @remarks
     * The IssueConnection does not have title filter for now, and the number of results is limited to 100.
     * For now, if issues with the labels are more than 100, we have to request the next page(not implemented yet).
     */
    getIssue({ accessToken, issueId, issueTitle, }: {
        accessToken: VssueAPI.AccessToken;
        issueId?: string | number;
        issueTitle?: string;
    }): Promise<VssueAPI.Issue | null>;
    /**
     * Create a new issue
     *
     * @param options.accessToken - User access token
     * @param options.title - The title of issue
     * @param options.content - The content of issue
     *
     * @return The created issue
     *
     * @see https://developer.github.com/v4/mutation/createissue/
     * @see https://developer.github.com/v4/input_object/createissueinput/
     *
     * @remarks
     * Creating issue requires repositoryId, which should be requested in an extra request.
     * Creating issue with labels requires labelIds, which should be requested in an extra request, or create the label if it does not exist.
     * Endpoints for creating labels has not been implemented by GitHub yet (see https://developer.github.com/v4/mutation/createlabel/)
     *
     * For these reasons, fallback to v3 for now
     */
    postIssue({ accessToken, title, content, }: {
        accessToken: VssueAPI.AccessToken;
        title: string;
        content: string;
    }): Promise<VssueAPI.Issue>;
    /**
     * Get comments of this page according to the issue id
     *
     * @param options.accessToken - User access token
     * @param options.issueId - The id of issue
     * @param options.query - The query parameters
     *
     * @return The comments
     *
     * @see https://developer.github.com/v4/object/issuecommentconnection/
     *
     * @reamrks
     * No offset implemented, so it's difficult to implement REST-like pagination
     * For now, we use an internal `_pageInfo` var to hack that
     */
    getComments({ accessToken, issueId, query: { page, perPage, sort, }, }: {
        accessToken: VssueAPI.AccessToken;
        issueId: string | number;
        query?: Partial<VssueAPI.Query>;
    }): Promise<VssueAPI.Comments>;
    /**
     * Create a new comment
     *
     * @param options.accessToken - User access token
     * @param options.issueId - The id of issue
     * @param options.content - The content of comment
     *
     * @return The created comment
     *
     * @see https://developer.github.com/v4/mutation/addcomment/
     * @see https://developer.github.com/v4/input_object/addcommentinput/
     */
    postComment({ accessToken, issueId, content, }: {
        accessToken: VssueAPI.AccessToken;
        issueId: string | number;
        content: string;
    }): Promise<VssueAPI.Comment>;
    /**
     * Edit a comment
     *
     * @param options.accessToken - User access token
     * @param options.commentId - The id of comment
     * @param options.content - The content of comment
     *
     * @return The edited comment
     *
     * @see https://developer.github.com/v4/mutation/updateissuecomment/
     * @see https://developer.github.com/v4/input_object/updateissuecommentinput/
     */
    putComment({ accessToken, commentId, content, }: {
        accessToken: VssueAPI.AccessToken;
        issueId: string | number;
        commentId: string | number;
        content: string;
    }): Promise<VssueAPI.Comment>;
    /**
     * Delete a comment
     *
     * @param options.accessToken - User access token
     * @param options.commentId - The id of comment
     *
     * @return `true` if succeed, `false` if failed
     *
     * @see https://developer.github.com/v4/mutation/deleteissuecomment/
     */
    deleteComment({ accessToken, commentId, }: {
        accessToken: VssueAPI.AccessToken;
        issueId: string | number;
        commentId: string | number;
    }): Promise<boolean>;
    /**
     * Get reactions of a comment
     *
     * @param options.accessToken - User access token
     * @param options.issueId - The id of issue
     * @param options.commentId - The id of comment
     *
     * @return The comments
     *
     * @remarks
     * This query has not been implemented, use the comments query instead
     */
    getCommentReactions({ accessToken, issueId, commentId, }: {
        accessToken: VssueAPI.AccessToken;
        issueId: string | number;
        commentId: string | number;
    }): Promise<VssueAPI.Reactions>;
    /**
     * Create a new reaction of a comment
     *
     * @param options.accessToken - User access token
     * @param options.commentId - The id of comment
     * @param options.reaction - The reaction
     *
     * @return `true` if succeed, `false` if already token
     *
     * @see https://developer.github.com/v4/mutation/addreaction/
     * @see https://developer.github.com/v4/input_object/addreactioninput/
     */
    postCommentReaction({ accessToken, commentId, reaction, }: {
        accessToken: VssueAPI.AccessToken;
        issueId: string | number;
        commentId: string | number;
        reaction: keyof VssueAPI.Reactions;
    }): Promise<boolean>;
    private _getQueryParams;
}
